/* automatically generated by rust-bindgen 0.63.0 */

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused)]
use libc::c_void;
use rrplug::high::vector::Vector3;

// primedev

pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type dtPolyRef = ::std::os::raw::c_uint;
#[doc = " The maximum number of vertices per navigation polygon.\n @ingroup detour"]
pub const DT_VERTS_PER_POLYGON: ::std::os::raw::c_int = 6;
#[doc = " The polygon is a standard convex polygon that is part of the surface of the mesh."]
pub const dtPolyTypes_DT_POLYTYPE_GROUND: dtPolyTypes = 0;
#[doc = " The polygon is an off-mesh connection consisting of two vertices."]
pub const dtPolyTypes_DT_POLYTYPE_OFFMESH_CONNECTION: dtPolyTypes = 1;
#[doc = " Flags representing the type of a navigation mesh polygon."]
pub type dtPolyTypes = ::std::os::raw::c_int;
#[doc = " Configuration parameters used to define multi-tile navigation meshes.\n The values are used to allocate space during the initialization of a navigation mesh.\n @see dtNavMesh::init()\n @ingroup detour"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtNavMeshParams {
    #[doc = "< The world space origin of the navigation mesh's tile space. [(x, y, z)]"]
    pub orig: [f32; 3usize],
    #[doc = "< The width of each tile. (Along the x-axis.)"]
    pub tileWidth: f32,
    #[doc = "< The height of each tile. (Along the z-axis.)"]
    pub tileHeight: f32,
    #[doc = "< The maximum number of tiles the navigation mesh can contain. This and maxPolys are used to calculate how many bits are needed to identify tiles and polygons uniquely."]
    pub maxTiles: ::std::os::raw::c_int,
    #[doc = "< The maximum number of polygons each tile can contain. This and maxTiles are used to calculate how many bits are needed to identify tiles and polygons uniquely."]
    pub maxPolys: ::std::os::raw::c_int,
    #[doc = " i hate this"]
    pub disjointPolyGroupCount: ::std::os::raw::c_int,
    pub reachabilityTableSize: ::std::os::raw::c_int,
    pub reachabilityTableCount: ::std::os::raw::c_int,
}
#[doc = " Defines an navigation mesh off-mesh connection within a dtMeshTile object.\n An off-mesh connection is a user defined traversable connection made up to two vertices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtOffMeshConnection {
    #[doc = " The endpoints of the connection."]
    pub origin: Vector3,
    pub dest: Vector3,
    #[doc = " The radius of the endpoints. [Limit: >= 0]"]
    pub rad: f32,
    #[doc = " The polygon reference of the connection within the tile."]
    pub poly: ::std::os::raw::c_ushort,
    #[doc = " Link flags.\n @note These are not the connection's user defined flags. Those are assigned via the\n connection's dtPoly definition. These are link flags used for internal purposes."]
    pub flags: ::std::os::raw::c_uchar,
    #[doc = " End point side."]
    pub side: ::std::os::raw::c_uchar,
    #[doc = " The id of the offmesh connection. (User assigned when the navigation mesh is built.)"]
    pub userId: ::std::os::raw::c_uint,
    pub unk: [f32; 3usize],
    pub another_unk: f32,
}
#[doc = " A navigation mesh based on tiles of convex polygons.\n @ingroup detour"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtNavMesh {
    #[doc = "< Tile hash lookup."]
    pub m_posLookup: *mut *mut dtMeshTile,
    #[doc = "< Freelist of tiles."]
    pub m_nextFree: *mut dtMeshTile,
    #[doc = "< List of tiles."]
    pub m_tiles: *mut dtMeshTile,
    pub disjointPolyGroup: *mut ::std::os::raw::c_void,
    pub reachabilityTable: *mut *mut ::std::os::raw::c_int,
    pub unk: ::std::os::raw::c_longlong,
    #[doc = "< Current initialization params. TODO: do not store this info twice."]
    pub m_params: dtNavMeshParams,
    #[doc = "< Origin of the tile (0,0)"]
    pub m_orig: [f32; 3usize],
    #[doc = "< Dimensions of each tile."]
    pub m_tileWidth: f32,
    #[doc = "< Dimensions of each tile."]
    pub m_tileHight: f32,
    pub m_pad: ::std::os::raw::c_int,
    #[doc = "< Max number of tiles."]
    pub m_maxTiles: ::std::os::raw::c_int,
    #[doc = "< Tile hash lookup size (must be pot)."]
    pub m_tileLutSize: ::std::os::raw::c_int,
    #[doc = "< Tile hash lookup mask."]
    pub m_tileLutMask: ::std::os::raw::c_int,
    #[doc = "< Number of salt bits in the tile ID."]
    pub m_saltBits: ::std::os::raw::c_int,
    #[doc = "< Number of tile bits in the tile ID."]
    pub m_tileBits: ::std::os::raw::c_int,
    #[doc = "< Number of poly bits in the tile ID."]
    pub m_polyBits: ::std::os::raw::c_int,
}
#[doc = " Defines the location of detail sub-mesh data within a dtMeshTile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtPolyDetail {
    #[doc = "< The offset of the vertices in the dtMeshTile::detailVerts array."]
    pub vertBase: ::std::os::raw::c_uint,
    #[doc = "< The offset of the triangles in the dtMeshTile::detailTris array."]
    pub triBase: ::std::os::raw::c_uint,
    #[doc = "< The number of vertices in the sub-mesh."]
    pub vertCount: ::std::os::raw::c_uchar,
    #[doc = "< The number of triangles in the sub-mesh."]
    pub triCount: ::std::os::raw::c_uchar,
}
#[doc = " Defines a navigation mesh tile.\n @ingroup detour"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtMeshTile {
    #[doc = "< Counter describing modifications to the tile."]
    pub salt: ::std::os::raw::c_int,
    #[doc = "< Index to the next free link."]
    pub linksFreeList: ::std::os::raw::c_uint,
    #[doc = "< The tile header."]
    pub header: *mut dtMeshHeader,
    #[doc = "< The tile polygons. [Size: dtMeshHeader::polyCount]"]
    pub polys: *mut dtPoly,
    pub unkPolyThing: *mut ::std::os::raw::c_void,
    #[doc = "< The tile vertices. [Size: dtMeshHeader::vertCount]"]
    pub verts: *mut f32,
    #[doc = "< The tile links. [Size: dtMeshHeader::maxLinkCount]"]
    pub links: *mut dtLink,
    #[doc = "< The tile's detail sub-meshes. [Size: dtMeshHeader::detailMeshCount]"]
    pub detailMeshes: *mut dtPolyDetail,
    #[doc = " The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]"]
    pub detailVerts: *mut f32,
    #[doc = " The detail mesh's triangles. [(vertA, vertB, vertC, triFlags) * dtMeshHeader::detailTriCount].\n See dtDetailTriEdgeFlags and dtGetDetailTriEdgeFlags."]
    pub detailTris: *mut ::std::os::raw::c_uchar,
    #[doc = " The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]\n (Will be null if bounding volumes are disabled.)"]
    pub bvTree: *mut dtBVNode,
    #[doc = "< The tile off-mesh connections. [Size: dtMeshHeader::offMeshConCount]"]
    pub offMeshConnections: *mut dtOffMeshConnection,
    #[doc = "< The tile data. (Not directly accessed under normal situations.)"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the tile data."]
    pub dataSize: ::std::os::raw::c_int,
    #[doc = "< Tile flags. (See: #dtTileFlags)"]
    pub flags: ::std::os::raw::c_int,
    #[doc = "< The next free tile, or the next tile in the spatial grid."]
    pub next: *mut dtMeshTile,
    pub unk: ::std::os::raw::c_longlong,
}
#[doc = " Provides high level information related to a dtMeshTile object.\n @ingroup detour"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtMeshHeader {
    #[doc = "< Tile magic number. (Used to identify the data format.)"]
    pub magic: ::std::os::raw::c_int,
    #[doc = "< Tile data format version number."]
    pub version: ::std::os::raw::c_int,
    #[doc = "< The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)"]
    pub x: ::std::os::raw::c_int,
    #[doc = "< The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)"]
    pub y: ::std::os::raw::c_int,
    #[doc = "< The layer of the tile within the dtNavMesh tile grid. (x, y, layer)"]
    pub layer: ::std::os::raw::c_int,
    #[doc = "< The user defined id of the tile."]
    pub userId: ::std::os::raw::c_uint,
    #[doc = "< The number of polygons in the tile."]
    pub polyCount: ::std::os::raw::c_int,
    pub sth_per_poly: ::std::os::raw::c_int,
    #[doc = "< The number of vertices in the tile."]
    pub vertCount: ::std::os::raw::c_int,
    #[doc = "< The number of allocated links."]
    pub maxLinkCount: ::std::os::raw::c_int,
    pub detailMeshCount: ::std::os::raw::c_int,
    #[doc = " The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)"]
    pub detailVertCount: ::std::os::raw::c_int,
    #[doc = "< The number of triangles in the detail mesh."]
    pub detailTriCount: ::std::os::raw::c_int,
    #[doc = "< The number of bounding volume nodes. (Zero if bounding volumes are disabled.)"]
    pub bvNodeCount: ::std::os::raw::c_int,
    #[doc = "< The number of off-mesh connections."]
    pub offMeshConCount: ::std::os::raw::c_int,
    #[doc = "< The index of the first polygon which is an off-mesh connection."]
    pub offMeshBase: ::std::os::raw::c_int,
    #[doc = "< The height of the agents using the tile."]
    pub walkableHeight: f32,
    #[doc = "< The radius of the agents using the tile."]
    pub walkableRadius: f32,
    #[doc = "< The maximum climb height of the agents using the tile."]
    pub walkableClimb: f32,
    #[doc = "< The minimum bounds of the tile's AABB. [(x, y, z)]"]
    pub bmin: [f32; 3usize],
    #[doc = "< The maximum bounds of the tile's AABB. [(x, y, z)]"]
    pub bmax: [f32; 3usize],
    #[doc = " The bounding volume quantization factor."]
    pub bvQuantFactor: f32,
}
#[doc = " Defines a polygon within a dtMeshTile object.\n @ingroup detour"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtPoly {
    #[doc = " Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)"]
    pub firstLink: ::std::os::raw::c_uint,
    #[doc = " The indices of the polygon's vertices.\n The actual vertices are located in dtMeshTile::verts."]
    pub verts: [::std::os::raw::c_ushort; 6usize],
    #[doc = " Packed data representing neighbor polygons references and flags for each edge."]
    pub neis: [::std::os::raw::c_ushort; 6usize],
    #[doc = " The user defined polygon flags."]
    pub flags: ::std::os::raw::c_ushort,
    #[doc = " The number of vertices in the polygon."]
    pub vertCount: ::std::os::raw::c_uchar,
    #[doc = " The bit packed area id and polygon type.\n @note Use the structure's set and get methods to acess this value."]
    pub areaAndtype: ::std::os::raw::c_uchar,
    pub disjointSetId: ::std::os::raw::c_ushort,
    pub unk: ::std::os::raw::c_ushort,
    pub org: Vector3,
}
#[doc = " Defines a link between polygons.\n @note This structure is rarely if ever used by the end user.\n @see dtMeshTile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtLink {
    #[doc = "< Neighbour reference. (The neighbor that is linked to.)"]
    pub ref_: dtPolyRef,
    #[doc = "< Index of the next link."]
    pub next: ::std::os::raw::c_uint,
    #[doc = "< Index of the polygon edge that owns this link."]
    pub edge: ::std::os::raw::c_uchar,
    #[doc = "< If a boundary link, defines on which side the link is."]
    pub side: ::std::os::raw::c_uchar,
    #[doc = "< If a boundary link, defines the minimum sub-edge area."]
    pub bmin: ::std::os::raw::c_uchar,
    #[doc = "< If a boundary link, defines the maximum sub-edge area."]
    pub bmax: ::std::os::raw::c_uchar,
    pub jumpType: ::std::os::raw::c_uchar,
    pub otherUnk: ::std::os::raw::c_uchar,
    pub reverseLinkIndex: ::std::os::raw::c_ushort,
}
#[doc = " Bounding volume node.\n @note This structure is rarely if ever used by the end user.\n @see dtMeshTile"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtBVNode {
    #[doc = "< Minimum bounds of the node's AABB. [(x, y, z)]"]
    pub bmin: [::std::os::raw::c_ushort; 3usize],
    #[doc = "< Maximum bounds of the node's AABB. [(x, y, z)]"]
    pub bmax: [::std::os::raw::c_ushort; 3usize],
    #[doc = "< The node's index. (Negative for escape sequence.)"]
    pub i: ::std::os::raw::c_int,
}

// Ghidra

pub type undefined = ::std::os::raw::c_uchar;
pub type bool_ = ::std::os::raw::c_uchar;
pub type byte = ::std::os::raw::c_uchar;
pub type dword = ::std::os::raw::c_uint;
pub type longlong = ::std::os::raw::c_longlong;
pub type qword = ::std::os::raw::c_ulonglong;
pub type uchar = ::std::os::raw::c_uchar;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type ulonglong = ::std::os::raw::c_ulonglong;
pub type undefined1 = ::std::os::raw::c_uchar;
pub type undefined2 = ::std::os::raw::c_ushort;
pub type undefined3 = ::std::os::raw::c_uint;
pub type undefined4 = ::std::os::raw::c_uint;
pub type undefined8 = ::std::os::raw::c_ulonglong;
pub type ushort = ::std::os::raw::c_ushort;
pub type wchar16 = ::std::os::raw::c_ushort;
pub type wchar_t = ::std::os::raw::c_short;
pub type word = ::std::os::raw::c_ushort;
pub type PdtLink = *mut dtLink;
pub type PdtMeshHeader = *mut dtMeshHeader;
pub type PdtMeshTile = *mut dtMeshTile;
pub type PdtPoly = *mut dtPoly;
pub type PdtPolyDetail = *mut dtPolyDetail;
pub type PVector3 = *mut Vector3;
pub type PdtNavMesh = *mut dtNavMesh;
pub type PdtNavMeshParams = *mut dtNavMeshParams;
pub type PdtNavMeshQuery = *mut dtNavMeshQuery;
pub type PS6 = *mut S6;
pub type PS3 = *mut S3;
pub type PS1 = *mut S1;
pub type PS5 = *mut S5;
pub type PS4 = *mut S4;
pub type PS2 = *mut S2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S3 {
    pub entry_0: longlong,
    pub entry_1: *mut S4,
    pub entry_2: [::std::os::raw::c_char; 12usize],
    pub entry_3: ::std::os::raw::c_int,
    pub entry_4: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S4 {
    pub entry_0: longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S5 {
    pub entry_0: longlong,
    pub entry_1: ::std::os::raw::c_int,
    pub entry_2: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S6 {
    pub entry_0: [::std::os::raw::c_char; 4672usize],
    pub entry_1: ::std::os::raw::c_int,
    pub entry_2: [::std::os::raw::c_char; 868usize],
    pub entry_3: ::std::os::raw::c_int,
    pub entry_4: [::std::os::raw::c_char; 188usize],
    pub entry_5: ::std::os::raw::c_int,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtQueryData {
    pub status: dtStatus,
    pub lastBestNode: *const dtBVNode,
    pub lastBestNodeCost: f32,
    pub startRef: dtPolyRef,
    pub endRef: dtPolyRef,
    pub startPos: Vector3,
    pub endPos: Vector3,
    pub filter: *const dtQueryFilter,
    pub options: u32,
    pub raycastLimitSqr: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtNodeQueue {
    pub m_heap: *const *const (),
    pub m_capacity: i32,
    pub m_size: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtNavMeshQuery {
    pub nav: *mut dtNavMesh,
    pub data: dtQueryData,
    pub m_tinyNodePool: *const c_void,
    pub m_nodePool: *const c_void,
    pub m_openList: *const dtNodeQueue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S1 {
    pub entry_0: longlong,
    pub entry_1: *mut S2,
    pub entry_2: longlong,
    pub entry_3: ::std::os::raw::c_int,
    pub entry_4: ::std::os::raw::c_int,
    pub entry_5: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct S2 {
    pub entry_0: longlong,
}
pub type PdtQueryFilter = *mut dtQueryFilter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dtQueryFilter {
    pub m_areaCost: [f32; 32usize],
    pub m_includeFlags: ushort,
    pub m_excludeFlags: ushort,
}
pub type dtStatus = uint;
pub type dtStatus64 = i64;

// CAI

pub const MAX_HULLS: ::std::os::raw::c_int = 5;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAI_NodeLink {
    pub srcId: ::std::os::raw::c_short,
    pub destId: ::std::os::raw::c_short,
    pub hulls: [bool; 5usize],
    pub unk0: ::std::os::raw::c_char,
    pub unk1: ::std::os::raw::c_char,
    pub unk2: [::std::os::raw::c_char; 5usize],
    pub flags: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAI_NodeLinkDisk {
    pub srcId: ::std::os::raw::c_short,
    pub destId: ::std::os::raw::c_short,
    pub unk0: ::std::os::raw::c_char,
    pub hulls: [bool; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAI_Node {
    pub index: ::std::os::raw::c_int,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub hulls: [f32; 5usize],
    pub yaw: f32,
    pub unk0: ::std::os::raw::c_int,
    pub unk1: ::std::os::raw::c_int,
    pub unk2: [::std::os::raw::c_int; 5usize],
    pub unk3: [::std::os::raw::c_char; 5usize],
    pub pad: [::std::os::raw::c_char; 3usize],
    pub unk4: [f32; 5usize],
    pub links: *mut *mut CAI_NodeLink,
    pub unk5: [::std::os::raw::c_char; 16usize],
    pub linkcount: ::std::os::raw::c_int,
    pub unk11: ::std::os::raw::c_int,
    pub unk6: ::std::os::raw::c_short,
    pub unk7: [::std::os::raw::c_char; 16usize],
    pub unk8: ::std::os::raw::c_short,
    pub unk9: [::std::os::raw::c_char; 8usize],
    pub unk10: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAI_NodeDisk {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub yaw: f32,
    pub hulls: [f32; 5usize],
    pub unk0: ::std::os::raw::c_char,
    pub unk1: ::std::os::raw::c_int,
    pub unk2: [::std::os::raw::c_short; 5usize],
    pub unk3: [::std::os::raw::c_char; 5usize],
    pub unk4: ::std::os::raw::c_short,
    pub unk5: ::std::os::raw::c_short,
    pub unk6: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnkNodeStruct0 {
    pub index: ::std::os::raw::c_int,
    pub unk0: ::std::os::raw::c_char,
    pub unk1: ::std::os::raw::c_char,
    pub pad0: [::std::os::raw::c_char; 2usize],
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub pad5: [::std::os::raw::c_char; 4usize],
    pub unk2: *mut ::std::os::raw::c_int,
    pub pad1: [::std::os::raw::c_char; 16usize],
    pub unkcount0: ::std::os::raw::c_int,
    pub pad2: [::std::os::raw::c_char; 4usize],
    pub unk3: *mut ::std::os::raw::c_int,
    pub pad3: [::std::os::raw::c_char; 16usize],
    pub unkcount1: ::std::os::raw::c_int,
    pub pad4: [::std::os::raw::c_char; 132usize],
    pub unk5: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnkLinkStruct1 {
    pub unk0: ::std::os::raw::c_short,
    pub unk1: ::std::os::raw::c_short,
    pub unk2: ::std::os::raw::c_int,
    pub unk3: ::std::os::raw::c_char,
    pub unk4: ::std::os::raw::c_char,
    pub unk5: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAI_ScriptNode {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub scriptdata: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAI_Network {
    pub unk0: [::std::os::raw::c_char; 8usize],
    pub linkcount: ::std::os::raw::c_int,
    pub unk1: [::std::os::raw::c_char; 124usize],
    pub zonecount: ::std::os::raw::c_int,
    pub unk2: [::std::os::raw::c_char; 16usize],
    pub unk5: ::std::os::raw::c_int,
    pub unk6: [::std::os::raw::c_char; 4usize],
    pub hintcount: ::std::os::raw::c_int,
    pub hints: [::std::os::raw::c_short; 2000usize],
    pub scriptnodecount: ::std::os::raw::c_int,
    pub scriptnodes: [CAI_ScriptNode; 4000usize],
    pub nodecount: ::std::os::raw::c_int,
    pub nodes: *mut *mut CAI_Node,
}
